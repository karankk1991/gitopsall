apiVersion: extensions/v1beta1
kind: Deployment
metadata:
    name: {{ .Values.nodeName }}
    {{- if .Values.deployment.annotations }}
    annotations:
{{ toYaml .Values.deployment.annotations | indent 8 }}
    {{- end }}
    namespace: {{ .Values.metadata.namespace }}
    labels:
      app.kubernetes.io/name: {{ .Values.nodeName }}
      helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
      app.kubernetes.io/managed-by: {{ .Release.Service }}
      app.kubernetes.io/instance: {{ .Release.Name }}
spec:
    replicas: {{ .Values.replicas }}
    strategy:
      type: Recreate
      rollingUpdate: null
    template:
      metadata:
        labels:
          app: {{ .Values.nodeName }}
          app.kubernetes.io/name: {{ .Values.nodeName }}
          app.kubernetes.io/instance: {{ .Release.Name }} 
      spec:
        serviceAccountName: {{ $.Values.vault.serviceaccountname }}
        hostname: {{ .Values.nodeName }}
        securityContext:
          fsGroup: 1000
        containers:
        - name: {{ .Values.nodeName }}
          image: {{ .Values.image.containerName }} 
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
            cp app.jar {{ .Values.volume.mountPath }}/app.jar;
            cd {{ .Values.volume.mountPath }}/;
            cat app.properties
            # java $JAVA_OPTIONS -jar app.jar --spring.config.location=/opt/corda/app.properties 2>&1
            if [ -d "{{ .Values.volume.mountPath }}/cordapps" ]; then
               echo "Found the cordapps directory"
               ls -ltr {{ .Values.volume.mountPath }}/cordapps;
               java $JAVA_OPTIONS -cp app.jar -Dloader.path={{ .Values.volume.mountPath }}/{{ .Values.smartContract.path }}/{{ .Values.smartContract.name }} org.springframework.boot.loader.PropertiesLauncher --spring.config.location={{ .Values.volume.mountPath }}/app.properties 2>&1
            else
               echo "NO cordapps directory"
               java $JAVA_OPTIONS -jar app.jar --spring.config.location={{ .Values.volume.mountPath }}/app.properties 2>&1
            fi
          resources:
            limits:
              memory: {{ .Values.resources.limits }}
            requests:
              memory: {{ .Values.resources.requests }}
          ports:
            - containerPort: {{ .Values.nodeConf.port }}
              name: web
          env:
            - name: JAVA_OPTIONS
              value: {{ .Values.smartContract.JAVA_OPTIONS }}
            - name: CORDA_HOME
              value: {{ .Values.volume.mountPath }}
          volumeMounts:
          - name: {{ .Values.nodeName }}volume
            mountPath: "{{ .Values.volume.mountPath }}"
            readOnly: false
          - name: certificates
            mountPath: "{{ .Values.volume.mountPath }}/certificates"
            readOnly: false
          - name: nodeprops
            mountPath: "{{ .Values.volume.mountPath }}/app.properties"
            subPath: "app.properties"            
            readOnly: false      
        initContainers:
        - name: create-properties
          image : {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: VAULT_ADDR
             value: {{ $.Values.vault.address }}
           - name: KUBERNETES_AUTH_PATH
             value: {{ $.Values.vault.authpath }}
           - name: VAULT_APP_ROLE 
             value: {{ $.Values.vault.role }}
           - name: MOUNT_PATH
             value: {{ .Values.volume.mountPath }}
           - name: SECRET_PREFIX
             value: {{.Values.vault.secretprefix}}
           - name: KS_SECRET_PREFIX
             value: {{ .Values.vault.keystoresecretprefix }}
           - name: DB_SECRET_PREFIX
             value: {{ .Values.vault.dbsecretprefix }}
           - name: RPCUSER_SECRET_PREFIX
             value: {{ .Values.vault.rpcusersecretprefix }}
          command: ["/bin/sh","-c"]
          args:
          - |-
            #!/bin/bash
            ls  -ltr {{ .Values.volume.mountPath }}/;
            rm -f {{ .Values.volume.mountPath }}/app.properties;
            touch {{ .Values.volume.mountPath }}/app.properties;
            ls  -ltr ${MOUNT_PATH}/;
            KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
                              
            VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')          
            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${KS_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            CONF_KEYSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["keyStorePassword"]')
            CONF_TRUSTSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["trustStorePassword"]')
            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${DB_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            CONF_DATASOURCEPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["dataSourcePassword"]')           
            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${RPCUSER_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            CONF_RPCPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["{{ .Values.credentials.rpcUser }}"]')
            
            cat << EOF > {{ .Values.volume.mountPath }}/app.properties
            config.rpc.username={{ .Values.credentials.rpcUser }}
            config.rpc.password=${CONF_RPCPASSWORD}
            config.rpc.host={{ .Values.nodeConf.node }}
            config.rpc.port={{ .Values.nodeConf.nodeRpcPort }}
            config.controller.name={{ .Values.nodeConf.controllerName }}
            config.main.controller.name=MainController
            config.ssl.trustStorePath={{ .Values.nodeConf.trustStorePath }}
            config.ssl.trustStorePassword=${CONF_TRUSTSTOREPASSWORD}
            config.ssl.trustStoreProvider={{ .Values.nodeConf.trustStoreProvider }}
            config.legalName="{{ .Values.nodeConf.legalName }}"
            # Define a custom port instead of the default 8080
            server.port={{ .Values.nodeConf.port }}
            
            # Tell Spring Security (if used) to require requests over HTTPS
            security.require-ssl={{ .Values.nodeConf.useSSL }}
            
            # The format used for the keystore
            server.ssl.key-store-type={{ .Values.nodeConf.trustStoreProvider }}
            # The path to the keystore containing the certificate
            server.ssl.key-store={{ .Values.nodeConf.trustStorePath }}
            # The password used to generate the certificate
            server.ssl.key-store-password=${CONF_KEYSTOREPASSWORD}
            # The alias mapped to the certificate
            server.ssl.key-alias={{ .Values.nodeConf.tlsAlias }}
            EOF
            #echo "Created node.conf for the node"
            rm -f {{ .Values.volume.mountPath }}/network-parameters;
            ls  -ltr {{ .Values.volume.mountPath }}/;
          volumeMounts:
          - name: nodeprops
            mountPath: "{{ .Values.volume.mountPath }}/"
        - name: init-downloadjars
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          command: ["sh", "-c"]
          args:
          - |-
               #!/usr/bin/env sh
               #Can be used to download any specific database drivers
          volumeMounts:
          - name: {{ .Values.nodeName }}volume
            mountPath: "{{ .Values.volume.mountPath }}"
            readOnly: false
        - name: node-healthcheck
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
            COUNTER=1
            FLAG=true
            while [ "$COUNTER" -le {{ $.Values.node.readinessthreshold }} ]
            do
              NODE={{ .Values.nodeConf.node }}:{{ .Values.nodeConf.nodeRpcPort }}
              STATUS=$(nc -vz $NODE 2>&1 | grep -c open )
              if [ "$STATUS" == 0 ]
              then
                FLAG=false
              else
                FLAG=true                
                echo "node up and running"
              fi   
              if [ "$FLAG" == false ]
              then                
                echo "Retry attempted $COUNTER times, retrying after {{ $.Values.node.readinesscheckinterval }} seconds"
                COUNTER=`expr "$COUNTER" + 1`
                sleep {{ $.Values.node.readinesscheckinterval }}			
              else
                echo "SUCCESS!"
                echo "node up and running!"
                exit 0
                break
              fi   
            done
            if [ "$COUNTER" -gt {{ $.Values.node.readinessthreshold }} ] || [ "$FLAG" == false ] 
            then
              echo "Retry attempted $COUNTER times, no node up and running. Giving up!"
              exit 1
              break
            fi
        - name: init-certificates
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: VAULT_ADDR
             value: {{ $.Values.vault.address }}
           - name: KUBERNETES_AUTH_PATH
             value: {{ $.Values.vault.authpath }}
           - name: VAULT_APP_ROLE 
             value: {{ $.Values.vault.role }}
           - name: MOUNT_PATH
             value: {{ .Values.volume.mountPath }}
           - name: VAULT_NODE_NAME
             value: {{ .Values.nodeName }}
           - name: CERTS_SECRET_PREFIX
             value: {{ .Values.vault.certsecretprefix }}
          command: ["sh", "-c"]
          args:
          - |-
               #!/usr/bin/env sh
               validateVaultResponse () {
               if echo ${2} | grep "errors"; then
                echo "ERROR: unable to retrieve ${1}: ${2}"
                exit 1
                fi
               }

               KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
                              
               #echo "Getting secrets from Vault Server: ${VAULT_ADDR}"
               # Login to Vault and so I can get an approle token

               VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')          
                
               validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
               
               OUTPUT_PATH=${MOUNT_PATH}
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/nodekeystore | jq -r 'if .errors then . else . end')
               validateVaultResponse "secret (${CERTS_SECRET_PREFIX}/nodekeystore)" "${LOOKUP_SECRET_RESPONSE}"
               TLS_NODEKEYSTORE=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["nodekeystore.jks"]')
               echo "${TLS_NODEKEYSTORE}" | base64 -d > ${OUTPUT_PATH}/nodekeystore.jks
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/sslkeystore | jq -r 'if .errors then . else . end')
               validateVaultResponse "secret (${CERTS_SECRET_PREFIX}/sslkeystore)" "${LOOKUP_SECRET_RESPONSE}"
               TLS_SSLKEYSTORE=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["sslkeystore.jks"]')
               echo "${TLS_SSLKEYSTORE}" | base64 -d > ${OUTPUT_PATH}/sslkeystore.jks
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/truststore | jq -r 'if .errors then . else . end')
               validateVaultResponse "secret (${CERTS_SECRET_PREFIX}/truststore)" "${LOOKUP_SECRET_RESPONSE}"
               TLS_TRUSTSTORE=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["truststore.jks"]')
               echo "${TLS_TRUSTSTORE}" | base64 -d > ${OUTPUT_PATH}/truststore.jks
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/networkmaptruststore | jq -r 'if .errors then . else . end')
               validateVaultResponse "secret (${CERTS_SECRET_PREFIX}/networkmaptruststore)" "${LOOKUP_SECRET_RESPONSE}"
               TLS_NMS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["network-map-truststore.jks"]')
               echo "${TLS_NMS}" | base64 -d > ${OUTPUT_PATH}/network-map-truststore.jks       
          volumeMounts:
          - name: certificates
            mountPath: {{ .Values.volume.mountPath }}/ 
        imagePullSecrets:
          - name: {{ .Values.image.imagePullSecret }}
        volumes:
          - name: {{ .Values.nodeName }}volume
            persistentVolumeClaim:
              claimName: {{ .Values.nodeName }}-pvc
          - name: certificates
            emptyDir:
            medium: Memory
          - name: nodeprops
            emptyDir:
            medium: Memory