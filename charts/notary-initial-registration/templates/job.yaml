apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.nodeName }}-initial-registration
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app: {{ .Values.nodeName }}-initial-registration
    app.kubernetes.io/name: {{ .Values.nodeName }}-initial-registration
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
spec:
    replicas: {{ .Values.replicas }}
    strategy:
      type: Recreate
      rollingUpdate: null
    template:
      metadata:
        labels:
        app: {{ .Values.nodeName }}-initial-registration
        app.kubernetes.io/name: {{ .Values.nodeName }}-initial-registration
        app.kubernetes.io/instance: {{ .Release.Name }}
      spec:
        restartPolicy: "OnFailure"
        serviceAccountName: {{ $.Values.vault.serviceaccountname }}
        hostname: {{ .Values.nodeName }}
        securityContext:
          fsGroup: 1000
        containers:
        - name: {{ .Values.nodeName }}-initial-registration
          image: {{ .Values.image.containerName }}
          imagePullPolicy: Always
          env:
             - name: JAVA_OPTIONS
               value: -Xmx512m
             - name: CORDA_HOME
               value: /opt/corda
             - name: MOUNT_PATH
               value: {{ $.Values.volume.mountPath }}
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
              export DEFAULT_TRUSTSTORE_PASSWORD=`cat /opt/node/creds/default_truststore_cred`
              export KEYSTORE_PASSWORD=`cat /opt/node/creds/keystore_cred`
              export TRUSTSTORE_PASSWORD=`cat /opt/node/creds/truststore_cred`
              export DEFAULT_KEYSTORE_PASSWORD=`cat /opt/node/creds/default_keystore_cred`

              java $JAVA_OPTIONS -jar ${CORDA_HOME}/corda.jar --initial-registration --network-root-truststore-password ${DEFAULT_TRUSTSTORE_PASSWORD} --network-root-truststore ${MOUNT_PATH}/certificates/network-map-truststore.jks
             
              #changing password of keystore.
              keytool -storepasswd -new ${KEYSTORE_PASSWORD} -keystore ${MOUNT_PATH}/certificates/nodekeystore.jks -storepass ${DEFAULT_KEYSTORE_PASSWORD}
              keytool -storepasswd -new ${KEYSTORE_PASSWORD} -keystore ${MOUNT_PATH}/certificates/sslkeystore.jks -storepass ${DEFAULT_KEYSTORE_PASSWORD}
              keytool -storepasswd -new ${TRUSTSTORE_PASSWORD} -keystore ${MOUNT_PATH}/certificates/truststore.jks -storepass ${DEFAULT_TRUSTSTORE_PASSWORD}

              #changing password of nodekeystore.jks certificate.
              keytool -keypasswd -alias cordaclientca -keypass ${DEFAULT_KEYSTORE_PASSWORD} -new ${KEYSTORE_PASSWORD} -keystore ${MOUNT_PATH}/certificates/nodekeystore.jks -storepass ${KEYSTORE_PASSWORD}
              keytool -keypasswd -alias identity-private-key -keypass ${DEFAULT_KEYSTORE_PASSWORD} -new ${KEYSTORE_PASSWORD} -keystore ${MOUNT_PATH}/certificates/nodekeystore.jks -storepass ${KEYSTORE_PASSWORD}

              #changing password of sslkeystore.jks certificate.
              keytool -keypasswd -alias cordaclienttls -keypass ${DEFAULT_KEYSTORE_PASSWORD} -new ${KEYSTORE_PASSWORD} -keystore ${MOUNT_PATH}/certificates/sslkeystore.jks -storepass ${KEYSTORE_PASSWORD}
          volumeMounts:
          - name: {{ .Values.nodeName }}volume
            mountPath: "{{ $.Values.volume.mountPath }}"
            readOnly: false
          - name: certificates
            mountPath: "{{ $.Values.volume.mountPath }}/certificates"
            readOnly: false
          - name: nodeconf
            mountPath: "{{ $.Values.volume.mountPath }}/node.conf"
            subPath: "node.conf"
            readOnly: false
          - name: creds
            mountPath: "/opt/node/creds"
            readOnly: false
        - name: store-certs-in-vault
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
             - name: VAULT_ADDR
               value: {{ $.Values.vault.address }}
             - name: KUBERNETES_AUTH_PATH
               value: {{ $.Values.vault.authpath }}
             - name: VAULT_APP_ROLE
               value: {{ $.Values.vault.role }}
             - name: MOUNT_PATH
               value: {{ $.Values.volume.mountPath }}
             - name: VAULT_NODE_NAME
               value: {{ .Values.nodeName }}
             - name: RT_SECRET_PREFIX
               value: {{ .Values.vault.tokensecretprefix }}
             - name: CERTS_SECRET_PREFIX
               value: {{ .Values.vault.certsecretprefix }}
             - name: JAVA_OPTIONS
               value: -Xmx512m
             - name: CORDA_HOME
               value: {{ $.Values.volume.mountPath }}
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
              OUTPUT_PATH=${MOUNT_PATH}
              echo "Waiting for Initial registration to complete"
              sleep 45

              cd ${MOUNT_PATH}/;
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
              
              LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${RT_SECRET_PREFIX} | jq -r 'if .errors then . else . end')       
              ROOT_TOKEN=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["rootToken"]')
              
              (echo '{"nodekeystore.jks": "'; base64 ${MOUNT_PATH}/certificates/nodekeystore.jks; echo '"}') | curl -H "X-Vault-Token: ${ROOT_TOKEN}" -d @- ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/nodekeystore
              (echo '{"sslkeystore.jks": "'; base64 ${MOUNT_PATH}/certificates/sslkeystore.jks; echo '"}') | curl -H "X-Vault-Token: ${ROOT_TOKEN}" -d @- ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/sslkeystore
              (echo '{"truststore.jks": "'; base64 ${MOUNT_PATH}/certificates/truststore.jks; echo '"}') | curl -H "X-Vault-Token: ${ROOT_TOKEN}" -d @- ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/truststore
          volumeMounts:
          - name: {{ .Values.nodeName }}volume
            mountPath: "{{ $.Values.volume.mountPath }}"
            readOnly: false
          - name: certificates
            mountPath: "{{ $.Values.volume.mountPath }}/certificates"
            readOnly: false
          - name: nodeconf
            mountPath: "{{ $.Values.volume.mountPath }}/node.conf"
            subPath: "node.conf"
            readOnly: false
          - name: sql
            mountPath: "{{ $.Values.volume.mountPath }}/sql"
            readOnly: false
          livenessProbe:
            tcpSocket:
              port: 10002
            initialDelaySeconds: 15
            periodSeconds: 20
        initContainers:
        - name: init-nodeconf
          image : {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: VAULT_ADDR
             value: {{ $.Values.vault.address }}
           - name: KUBERNETES_AUTH_PATH
             value: {{ $.Values.vault.authpath }}
           - name: VAULT_APP_ROLE
             value: {{ $.Values.vault.role }}
           - name: MOUNT_PATH
             value: {{ $.Values.volume.mountPath }}
           - name: VAULT_NODE_NAME
             value: {{ .Values.nodeName }}
           - name: KS_SECRET_PREFIX
             value: {{ .Values.vault.keystoresecretprefix }}
           - name: DB_SECRET_PREFIX
             value: {{ .Values.vault.dbsecretprefix }}
           - name: RPCUSER_SECRET_PREFIX
             value: {{ .Values.vault.rpcusersecretprefix }}
          command: ["/bin/sh","-c"]
          args:
          - |-
            #!/bin/bash
            rm -f ${MOUNT_PATH}/node.conf;
            touch ${MOUNT_PATH}/node.conf;
            KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
            echo "Getting secrets from Vault Server"
            VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${KS_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            CONF_KEYSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["defaultKeyStorePassword"]')
            CONF_TRUSTSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["defaultTrustStorePassword"]')

            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${DB_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            CONF_DATASOURCEPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["{{ .Values.credentials.dataSourceUser }}"]')
            
            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${RPCUSER_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            cat << EOF > ${MOUNT_PATH}/node.conf
            basedir : "${MOUNT_PATH}"
            p2pAddress : "{{ .Values.nodeConf.p2p.url }}:{{ .Values.nodeConf.p2p.port }}"
            myLegalName : "{{ .Values.nodeConf.legalName }}"
            keyStorePassword : "${CONF_KEYSTOREPASSWORD}"
            trustStorePassword : "${CONF_TRUSTSTOREPASSWORD}"
            transactionCacheSizeMegaBytes : {{ .Values.nodeConf.transactionCacheSizeMegaBytes }}
            attachmentContentCacheSizeMegaBytes : {{ .Values.nodeConf.attachmentContentCacheSizeMegaBytes }}
            attachmentCacheBound : {{ .Values.nodeConf.attachmentCacheBound }}
            notary : {
                validating : {{ .Values.nodeConf.notary.validating }}
            }
            detectPublicIp = {{ .Values.nodeConf.detectPublicIp }}
            extraAdvertisedServiceIds: {{ .Values.nodeConf.extraAdvertisedServiceIds }}
            useHTTPS : {{ .Values.nodeConf.useHTTPS }}
            devMode : {{ .Values.nodeConf.devMode }}
            database.runMigration = {{ .Values.nodeConf.database.runMigration }}
            dataSourceProperties = {
                dataSourceClassName = "{{ .Values.nodeConf.dataSourceClassName }}"
                "dataSource.url" = "{{ .Values.nodeConf.dataSourceUrl }}"
                dataSource.user = {{ .Values.credentials.dataSourceUser }}
                dataSource.password = "${CONF_DATASOURCEPASSWORD}"
            }
            database = {
                serverNameTablePrefix = "{{ .Values.nodeConf.database.serverNameTablePrefix }}"
                transactionIsolationLevel = {{ .Values.nodeConf.database.transactionIsolationLevel }}
                exportHibernateJMXStatistics = {{ .Values.nodeConf.database.exportHibernateJMXStatistics }}
            }
            jarDirs = [{{ .Values.nodeConf.jarPath }}]
            EOF
            if [ -z "{{ .Values.nodeConf.compatibilityZoneURL }}" ]
            then
               echo 'networkServices {
                doormanURL = "{{ .Values.nodeConf.doormanURL }}"
                networkMapURL = "{{ .Values.nodeConf.networkMapURL }}"
            }' >> ${MOUNT_PATH}/node.conf
            else
               echo 'compatibilityZoneURL : "{{ .Values.nodeConf.compatibilityZoneURL }}"' >> ${MOUNT_PATH}/node.conf
            fi
            
            if [ -z "{{ .Values.nodeConf.jvmArgs }}" ]
            then
               echo 'jvmArgs is not configured'
            else
               echo 'jvmArgs = "{{ .Values.nodeConf.jvmArgs }}" ' >> ${MOUNT_PATH}/node.conf
            fi
            
            if [ -z "{{ .Values.nodeConf.sshd.port }}" ]
            then
               echo 'sshd port is not configured'
            else
               echo 'sshd { port = {{ .Values.nodeConf.sshd.port }} } ' >> ${MOUNT_PATH}/node.conf
            fi
            
            if [ -z "{{ .Values.nodeConf.systemProperties }}" ]
            then
               echo 'systemProperties is not configured'
            else
               echo 'systemProperties = {{ .Values.nodeConf.systemProperties }} ' >> ${MOUNT_PATH}/node.conf
            fi
            
            if [ -z "{{ .Values.nodeConf.exportJMXTo }}" ]
            then
               echo 'exportJMXTo is not configured'
            else
               echo 'exportJMXTo = {{ .Values.nodeConf.exportJMXTo }} ' >> ${MOUNT_PATH}/node.conf
            fi
            
            if [ -z "{{ .Values.nodeConf.messagingServerAddress }}" ]
            then
               echo 'The address of the ArtemisMQ broker instance is not configured'
            else
               echo 'messagingServerAddress : "{{ .Values.nodeConf.messagingServerAddress }}" ' >> ${MOUNT_PATH}/node.conf
            fi
               
            if [ -z "{{ .Values.credentials.rpcUser }}" ]
            then
               echo 'rpc useer is not configured'
            else
               echo 'rpcUsers : [' >> ${MOUNT_PATH}/node.conf
               {{- range $.Values.credentials.rpcUser }}
               echo '{ username={{ .name }} ,permissions={{ .permissions }}, ' >> ${MOUNT_PATH}/node.conf
               echo " password=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["{{ .name }}"]') }" >> ${MOUNT_PATH}/node.conf
               {{- end }}
               echo ']' >> ${MOUNT_PATH}/node.conf
            fi
            
            LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${KS_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
            if [ "{{ .Values.nodeConf.rpcSettings.useSsl }}" == true ]
            then
               echo "rpcSettings {
               standAloneBroker = {{ .Values.nodeConf.rpcSettings.standAloneBroker }}
               address = "{{ .Values.nodeConf.rpcSettings.address }}"
               adminAddress = "{{ .Values.nodeConf.rpcSettings.adminAddress }}"
               useSsl = {{ .Values.nodeConf.rpcSettings.useSsl }}
               ssl = {
                  keyStorePassword = $(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["sslkeyStorePassword"]')
                  trustStorePassword = $(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["ssltrustStorePassword"]')
                  certificatesDirectory = ${MOUNT_PATH}/{{ .Values.nodeConf.rpcSettings.ssl.certificatesDirectory }}
                  sslKeystore = ${MOUNT_PATH}/{{ .Values.nodeConf.rpcSettings.ssl.sslKeystoreFileName }}
                  trustStoreFile = ${MOUNT_PATH}/{{ .Values.nodeConf.rpcSettings.ssl.trustStoreFileName }}
                  }
                }" >> ${MOUNT_PATH}/node.conf
            else
                echo 'rpcSettings {
                standAloneBroker = {{ .Values.nodeConf.rpcSettings.standAloneBroker }}
                address = "{{ .Values.nodeConf.rpcSettings.address }}"
                adminAddress = "{{ .Values.nodeConf.rpcSettings.adminAddress }}"
                 }' >> ${MOUNT_PATH}/node.conf
            fi                 
            echo "node.conf created in ${MOUNT_PATH}"
          volumeMounts:
          - name: nodeconf
            mountPath: "{{ $.Values.volume.mountPath }}"
        - name: init-downloadjars
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: MOUNT_PATH
             value: {{ $.Values.volume.mountPath }}
          command: ["sh", "-c"]
          args:
          - |-
               #!/usr/bin/env sh
               mkdir -p ${MOUNT_PATH}/cordapps;
               chmod 777 -R ${MOUNT_PATH}/cordapps;
               rm -rf ${MOUNT_PATH}/corda-3.3-corda.jar;
               cd ${MOUNT_PATH}/ && wget https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda/{{ .Values.nodeConf.jarVersion }}/corda-{{ .Values.nodeConf.jarVersion }}.jar;
               cd ${MOUNT_PATH};
               mv ${MOUNT_PATH}/corda-{{ .Values.nodeConf.jarVersion }}.jar ${MOUNT_PATH}/corda.jar;
          volumeMounts:
          - name: {{ .Values.nodeName }}volume
            mountPath: "{{ $.Values.volume.mountPath }}"
            readOnly: false
        - name: init-network-map-truststore
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: VAULT_ADDR
             value: {{ $.Values.vault.address }}
           - name: KUBERNETES_AUTH_PATH
             value: {{ $.Values.vault.authpath }}
           - name: VAULT_APP_ROLE
             value: {{ $.Values.vault.role }}
           - name: MOUNT_PATH
             value: {{ $.Values.volume.mountPath }}
           - name: VAULT_NODE_NAME
             value: {{ .Values.nodeName }}
           - name: CERTS_SECRET_PREFIX
             value: {{ .Values.vault.certsecretprefix }}
           - name: NETWORK_MAP_URL
             value: {{ .Values.nodeConf.networkMapURL }}
           - name: RT_SECRET_PREFIX
             value: {{ .Values.vault.tokensecretprefix }}
          command: ["sh", "-c"]
          args:
          - |-
               #!/usr/bin/env sh
               validateVaultResponse () {
               if echo ${2} | grep "errors"; then
                echo "ERROR: unable to retrieve ${1}: ${2}"
                exit 1
                fi
               }                            
               
               validateVaultResponseNetworkMapTruststore () {
               if echo ${2} | grep "errors"; 
               then
                  echo "Getting network-map-truststore.jks from the networkmap."
                  cd ${OUTPUT_PATH}
                  curl -X GET $NETWORK_MAP_URL/network-map/truststore -o network-map-truststore.jks
                  (echo '{"network-map-truststore.jks": "'; base64 ${OUTPUT_PATH}/network-map-truststore.jks; echo '"}') | curl -H "X-Vault-Token: ${ROOT_TOKEN}" -d @- ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/networkmaptruststore
                  
               else
                  echo "network-map-truststore.jks already exist."
                  
                  TLS_NMS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["network-map-truststore.jks"]')
                  echo "${TLS_NMS}" | base64 -d > ${OUTPUT_PATH}/network-map-truststore.jks
               fi
               }
               
               
               KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
               VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')          
               validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
               OUTPUT_PATH=${MOUNT_PATH}               
                            
               LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${RT_SECRET_PREFIX} | jq -r 'if .errors then . else . end')       
               ROOT_TOKEN=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["rootToken"]')
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/networkmaptruststore | jq -r 'if .errors then . else . end')
               validateVaultResponseNetworkMapTruststore "secret (${CERTS_SECRET_PREFIX}/networkmaptruststore)" "${LOOKUP_SECRET_RESPONSE}"
                 
               
          volumeMounts:
          - name: certificates
            mountPath: {{ $.Values.volume.mountPath }}
        - name: init-certificates
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: VAULT_ADDR
             value: {{ $.Values.vault.address }}
           - name: KUBERNETES_AUTH_PATH
             value: {{ $.Values.vault.authpath }}
           - name: VAULT_APP_ROLE 
             value: {{ $.Values.vault.role }}
           - name: MOUNT_PATH
             value: {{ $.Values.volume.mountPath }}
           - name: VAULT_NODE_NAME
             value: {{ .Values.nodeName }}
           - name: CERTS_SECRET_PREFIX
             value: {{.Values.vault.certsecretprefix}}
          command: ["sh", "-c"]
          args:
          - |-
               #!/usr/bin/env sh
               validateVaultResponse () {
               if echo ${2} | grep "errors"; then
                echo "ERROR: unable to retrieve ${1}: ${2}"
                exit 1
                fi
               }
               validateVaultResponseCustomnodeKeystore () {
               if echo ${2} | grep "errors";
               then
                echo "custom nodekeystore.jks is not provided and new one will be created."
               else
                echo "Found custom nodekeystore.jks"
                echo "${NODE_KEY}" | base64 -d > ${OUTPUT_PATH}/nodekeystore.jks
               fi
               }
               validateVaultResponseKeystore () {
               if echo ${2} | grep "errors"; 
               then
                echo "Initial registration will create keystore ${1}"
               else
                echo "Initial registration was performed before."
                exit 1
               fi
               }
               KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
               VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')          
               validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
               OUTPUT_PATH=${MOUNT_PATH}
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/customnodekeystore )
               NODE_KEY=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["nodekeystore.jks"]')
               validateVaultResponseCustomnodeKeystore "secret (${CERTS_SECRET_PREFIX}/customnodekeystore)" "${LOOKUP_SECRET_RESPONSE}"
               
               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/nodekeystore | jq -r 'if .errors then . else . end')
               validateVaultResponseKeystore "secret on (${CERTS_SECRET_PREFIX}/nodekeystore)" "${LOOKUP_SECRET_RESPONSE}"

               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/sslkeystore | jq -r 'if .errors then . else . end')
               validateVaultResponseKeystore "secret on (${CERTS_SECRET_PREFIX}/sslkeystore)" "${LOOKUP_SECRET_RESPONSE}"

               LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/truststore | jq -r 'if .errors then . else . end')
               validateVaultResponseKeystore "secret on (${CERTS_SECRET_PREFIX}/truststore)" "${LOOKUP_SECRET_RESPONSE}"
          volumeMounts:
          - name: certificates
            mountPath: {{ $.Values.volume.mountPath }}       
        - name: changepermissions
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
           - name: VAULT_ADDR
             value: {{ $.Values.vault.address }}
           - name: KUBERNETES_AUTH_PATH
             value: {{ $.Values.vault.authpath }}
           - name: VAULT_APP_ROLE
             value: {{ $.Values.vault.role }}
           - name: MOUNT_PATH
             value: {{ $.Values.volume.mountPath }}
           - name: VAULT_NODE_NAME
             value: {{ .Values.nodeName }}
          command: ["sh", "-c"]
          args:
          - |-
            chmod 777 -R ${MOUNT_PATH}/;
          volumeMounts:
          - name: certificates
            mountPath: {{ $.Values.volume.mountPath }}
        - name: init-credential
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          env:
            - name: VAULT_ADDR
              value: {{.Values.vault.address}}
            - name: KUBERNETES_AUTH_PATH
              value: {{.Values.vault.authpath}}
            - name: VAULT_APP_ROLE
              value: {{.Values.vault.role}}
            - name: MOUNT_PATH
              value: /opt/node/creds
            - name: VAULT_NODE_NAME
              value: {{ .Values.nodeName }}
            - name: KS_SECRET_PREFIX
              value: {{ .Values.vault.keystoresecretprefix }}
          command: ["sh", "-c"]
          args:
          - |-
               #!/usr/bin/env sh
               validateVaultResponse () {
               if echo ${2} | grep "errors"; then
                echo "ERROR: unable to retrieve ${1}: ${2}"
                exit 1
                fi
               }

               KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
               echo "Getting secrets from Vault Server"
               VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')          
               validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
               OUTPUT_PATH=${MOUNT_PATH}

               LOOKUP_PWD_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${KS_SECRET_PREFIX} | jq -r 'if .errors then . else . end')
               DEFAULT_TRUSTSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["defaultTrustStorePassword"]')
               DEFAULT_KEYSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["defaultKeyStorePassword"]')
               KEYSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["keyStorePassword"]')
               TRUSTSTOREPASSWORD=$(echo ${LOOKUP_PWD_RESPONSE} | jq -r '.data["trustStorePassword"]')
               
               echo "${DEFAULT_TRUSTSTOREPASSWORD}" >> ${MOUNT_PATH}/default_truststore_cred
               echo "${KEYSTOREPASSWORD}" >> ${MOUNT_PATH}/keystore_cred
               echo "${TRUSTSTOREPASSWORD}" >> ${MOUNT_PATH}/truststore_cred
               echo "${DEFAULT_KEYSTOREPASSWORD}" >> ${MOUNT_PATH}/default_keystore_cred
          volumeMounts:
          - name: creds
            mountPath: "/opt/node/creds"
            readOnly: false
        - name: db-healthcheck
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: Always
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
            COUNTER=1
            FLAG=true                   
            while [ "$COUNTER" -le {{ $.Values.db.readinessthreshold }} ]
            do
              DB_NODE={{ .Values.nodeConf.dbUrl }}:{{ .Values.nodeConf.dbPort }}
              STATUS=$(nc -vz $DB_NODE 2>&1 | grep -c open )
              if [ "$STATUS" == 0 ]
              then
                FLAG=false
              else
                FLAG=true                
                echo "DB up and running"
              fi   
              if [ "$FLAG" == false ]
              then                
                echo "Retry attempted $COUNTER times, retrying after {{ $.Values.db.readinesscheckinterval }} seconds"
                COUNTER=`expr "$COUNTER" + 1`
                sleep {{ $.Values.db.readinesscheckinterval }}
              else
                echo "SUCCESS!"
                echo "DB up and running!"
                exit 0
                break
              fi   
            done
            if [ "$COUNTER" -gt {{ $.Values.db.readinessthreshold }} ] || [ "$FLAG" == false ] 
            then
              echo "Retry attempted $COUNTER times, no DB up and running. Giving up!"
              exit 1
              break
            fi
        imagePullSecrets:
          - name: {{ .Values.image.imagePullSecret }}
        volumes:
          - name: {{ .Values.nodeName }}volume
            emptyDir:
            medium: Memory
          - name: certificates
            emptyDir:
            medium: Memory
          - name: nodeconf
            emptyDir:
            medium: Memory
          - name: creds
            emptyDir:
            medium: Memory
          - name: sql
            emptyDir:
            medium: Memory